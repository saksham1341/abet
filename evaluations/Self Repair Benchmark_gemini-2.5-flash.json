{"benchmark_name": "Self Repair Benchmark", "run_id": "gemini-2.5-flash", "results": {"sr": 0.85, "ftsr": 0.7391304347826086, "scr": 1, "ats": 1.15}, "samples": [{"input": {"input_key": 7, "desired_task": "Perform a topological sort of a small DAG of tasks and print one valid ordering.", "incomplete_code": "from collections import deque\n\ngraph = {\n    'cook': ['eat'],\n    'shop': ['cook'],\n    'code': ['sleep'],\n    'eat': ['sleep'],\n    'sleep': []\n}\n\n\"\"\"We want a valid topological ordering such as:\n['code', 'shop', 'cook', 'eat', 'sleep']\n\"\"\"\n\ndef topo_sort(graph):\n    indeg = {node: 0 for node in graph}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            indeg[v] += 1\n\n    # queue of nodes with indegree 0\n    queue = deque([n for n, d in indeg.items() if d == 0])\n    order = []\n\n    while queue:\n        # BUG: using pop() instead of popleft() breaks deterministic BFS order\n        node = queue.pop()\n        order.append(node)\n        for v in graph[node]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                queue.append(v)\n\n    if len(order) != len(graph):\n        raise ValueError('graph has a cycle')\n\n    return order\n\nprint(topo_sort(graph))\n"}, "output": {"code_output": "['shop', 'code', 'cook', 'eat', 'sleep']", "tries": 1}, "target": "['code', 'shop', 'cook', 'eat', 'sleep']"}, {"input": {"input_key": 13, "desired_task": "Parse simple log lines of the form 'user=<name> action=<action>' and group actions per user in an OrderedDict, then print that mapping.", "incomplete_code": "import re\nimport collections\n\nlogs = [\n    \"user=alice action=login\",\n    \"user=bob action=download\",\n    \"user=alice action=upload\",\n    \"user=alice action=logout\",\n    \"user=bob action=logout\",\n]\n\n\"\"\"We want an OrderedDict mapping user -> list of actions in order of appearance.\n\"\"\"\n\ndef group_actions(logs):\n    pattern = re.compile(r\"user=(\\\\w+) action=(\\\\w+)\")\n    result = collections.OrderedDict()\n    for line in logs:\n        m = pattern.search(line)\n        if not m:\n            continue\n        user, action = m.groups()\n        if user not in result:\n            # BUG: accidentally overwrite existing mapping instead of appending list\n            result[user] = action\n        else:\n            # BUG: trying to append to string\n            result[user] += \",\" + action\n    return result\n\nprint(group_actions(logs))\n"}, "output": {"code_output": "OrderedDict({'alice': ['login', 'upload', 'logout'], 'bob': ['download', 'logout']})", "tries": 5}, "target": "OrderedDict([('alice', ['login', 'upload', 'logout']), ('bob', ['download', 'logout'])])"}, {"input": {"input_key": 14, "desired_task": "Evaluate an arithmetic expression string with +, -, *, / and integer division semantics, honoring operator precedence, and print the resulting integer.", "incomplete_code": "def eval_expr(expr):\n    \"\"\"Evaluate a flat expression like '3+5*2-8/4+6' using integer division.\n    No parentheses.\n    \"\"\"\n    # BUG: naive left-to-right evaluation ignoring precedence\n    total = 0\n    op = '+'\n    num = 0\n    for ch in expr + '+':\n        if ch.isdigit():\n            num = num * 10 + int(ch)\n        else:\n            if op == '+':\n                total += num\n            elif op == '-':\n                total -= num\n            elif op == '*':\n                total *= num\n            elif op == '/':\n                total //= num\n            op = ch\n            num = 0\n    return total\n\nexpr = '3+5*2-8/4+6'\nprint(eval_expr(expr))\n"}, "output": {"code_output": null, "tries": 0}, "target": "17"}]}