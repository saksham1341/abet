{"benchmark_name": "Self Repair Benchmark", "run_id": "gemini-2.5-flash", "results": {"sr": 0.85, "ftsr": 0.9411764705882353, "scr": 1.0, "ats": 1.7}, "samples": [{"input": {"input_key": 1, "desired_task": "Count word frequencies (case-insensitive, ignoring punctuation) in a given text and print the top 5 words as (word, count) sorted by descending frequency then alphabetically.", "incomplete_code": "import re\nfrom collections import Counter\n\ntext = \"This is a test. This test is only a test: in case of an actual emergency, the word 'test' would appear many times.\"\n\n# We want something like: [(\"test\", 3), (\"a\", 2), ...]\n\ndef top_k_words(text, k=5):\n    # split on non-letters, normalize case\n    words = re.findall(r\"[a-zA-Z']+\", text)  # BUG: missing .lower()\n    counts = Counter(words)\n\n    # sort by frequency desc, then word asc\n    # BUG: this is sorting by word first, then frequency\n    items = sorted(counts.items(), key=lambda kv: (kv[0], -kv[1]))\n    return items[:k]\n\nprint(top_k_words(text, k=5))\n"}, "output": {"code_output": "[('test', 4), ('a', 2), ('is', 2), ('this', 2), ('actual', 1)]", "tries": 6}, "target": "[('test', 3), ('a', 2), ('is', 2), ('this', 2), (\"'test'\", 1)]"}, {"input": {"input_key": 7, "desired_task": "Perform a topological sort of a small DAG of tasks and print one valid ordering.", "incomplete_code": "from collections import deque\n\ngraph = {\n    'cook': ['eat'],\n    'shop': ['cook'],\n    'code': ['sleep'],\n    'eat': ['sleep'],\n    'sleep': []\n}\n\n\"\"\"We want a valid topological ordering such as:\n['code', 'shop', 'cook', 'eat', 'sleep']\n\"\"\"\n\ndef topo_sort(graph):\n    indeg = {node: 0 for node in graph}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            indeg[v] += 1\n\n    # queue of nodes with indegree 0\n    queue = deque([n for n, d in indeg.items() if d == 0])\n    order = []\n\n    while queue:\n        # BUG: using pop() instead of popleft() breaks deterministic BFS order\n        node = queue.pop()\n        order.append(node)\n        for v in graph[node]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                queue.append(v)\n\n    if len(order) != len(graph):\n        raise ValueError('graph has a cycle')\n\n    return order\n\nprint(topo_sort(graph))\n"}, "output": {"code_output": "['shop', 'code', 'cook', 'eat', 'sleep']", "tries": 5}, "target": "['code', 'shop', 'cook', 'eat', 'sleep']"}, {"input": {"input_key": 13, "desired_task": "Parse simple log lines of the form 'user=<name> action=<action>' and group actions per user in an OrderedDict, then print that mapping.", "incomplete_code": "import re\nimport collections\n\nlogs = [\n    \"user=alice action=login\",\n    \"user=bob action=download\",\n    \"user=alice action=upload\",\n    \"user=alice action=logout\",\n    \"user=bob action=logout\",\n]\n\n\"\"\"We want an OrderedDict mapping user -> list of actions in order of appearance.\n\"\"\"\n\ndef group_actions(logs):\n    pattern = re.compile(r\"user=(\\\\w+) action=(\\\\w+)\")\n    result = collections.OrderedDict()\n    for line in logs:\n        m = pattern.search(line)\n        if not m:\n            continue\n        user, action = m.groups()\n        if user not in result:\n            # BUG: accidentally overwrite existing mapping instead of appending list\n            result[user] = action\n        else:\n            # BUG: trying to append to string\n            result[user] += \",\" + action\n    return result\n\nprint(group_actions(logs))\n"}, "output": {"code_output": "OrderedDict({'alice': ['login', 'upload', 'logout'], 'bob': ['download', 'logout']})", "tries": 5}, "target": "OrderedDict([('alice', ['login', 'upload', 'logout']), ('bob', ['download', 'logout'])])"}]}