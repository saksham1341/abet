{"benchmark_name": "Self Repair Benchmark", "run_id": "gemini-2.5-flash-lite", "results": {"sr": 0.75, "ftsr": 0.7777777777777778, "scr": 1.0, "ats": 0.9}, "samples": [{"input": {"input_key": 4, "desired_task": "Compute the length of the shortest path in an unweighted directed graph from 'A' to 'F' using BFS and print that distance.", "incomplete_code": "from collections import deque\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': ['D', 'E'],\n    'D': ['F'],\n    'E': ['F'],\n    'F': []\n}\n\n# We want the minimum number of edges from 'A' to 'F'.\n\ndef shortest_path_length(graph, start, target):\n    queue = deque([(start, 0)])\n    seen = set()\n\n    while queue:\n        node, dist = queue.popleft()\n        if node in seen:\n            continue\n        seen.add(node)\n\n        if node == target:\n            return dist\n\n        for neigh in graph.get(node, []):\n            # BUG: forgot to increment distance\n            queue.append((neigh, dist))\n\n    return None\n\nprint(shortest_path_length(graph, 'A', 'F'))\n"}, "output": {"code_output": null, "tries": 0}, "target": "3"}, {"input": {"input_key": 13, "desired_task": "Parse simple log lines of the form 'user=<name> action=<action>' and group actions per user in an OrderedDict, then print that mapping.", "incomplete_code": "import re\nimport collections\n\nlogs = [\n    \"user=alice action=login\",\n    \"user=bob action=download\",\n    \"user=alice action=upload\",\n    \"user=alice action=logout\",\n    \"user=bob action=logout\",\n]\n\n\"\"\"We want an OrderedDict mapping user -> list of actions in order of appearance.\n\"\"\"\n\ndef group_actions(logs):\n    pattern = re.compile(r\"user=(\\\\w+) action=(\\\\w+)\")\n    result = collections.OrderedDict()\n    for line in logs:\n        m = pattern.search(line)\n        if not m:\n            continue\n        user, action = m.groups()\n        if user not in result:\n            # BUG: accidentally overwrite existing mapping instead of appending list\n            result[user] = action\n        else:\n            # BUG: trying to append to string\n            result[user] += \",\" + action\n    return result\n\nprint(group_actions(logs))\n"}, "output": {"code_output": null, "tries": 0}, "target": "OrderedDict([('alice', ['login', 'upload', 'logout']), ('bob', ['download', 'logout'])])"}, {"input": {"input_key": 14, "desired_task": "Evaluate an arithmetic expression string with +, -, *, / and integer division semantics, honoring operator precedence, and print the resulting integer.", "incomplete_code": "def eval_expr(expr):\n    \"\"\"Evaluate a flat expression like '3+5*2-8/4+6' using integer division.\n    No parentheses.\n    \"\"\"\n    # BUG: naive left-to-right evaluation ignoring precedence\n    total = 0\n    op = '+'\n    num = 0\n    for ch in expr + '+':\n        if ch.isdigit():\n            num = num * 10 + int(ch)\n        else:\n            if op == '+':\n                total += num\n            elif op == '-':\n                total -= num\n            elif op == '*':\n                total *= num\n            elif op == '/':\n                total //= num\n            op = ch\n            num = 0\n    return total\n\nexpr = '3+5*2-8/4+6'\nprint(eval_expr(expr))\n"}, "output": {"code_output": "5", "tries": 1}, "target": "17"}, {"input": {"input_key": 17, "desired_task": "Generate all permutations of a small list of integers, sort them lexicographically, and print the list of permutations.", "incomplete_code": "import itertools\n\nnums = [1, 2, 3]\n\n\"\"\"We want all permutations in sorted order, e.g.:\n[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]\n\"\"\"\n\ndef all_permutations(nums):\n    perms = list(itertools.permutations(nums))\n    # BUG: not sorted; current order depends on itertools implementation\n    return perms\n\nprint(all_permutations(nums))\n"}, "output": {"code_output": null, "tries": 0}, "target": "[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]"}, {"input": {"input_key": 19, "desired_task": "Use Dijkstra's algorithm to compute the shortest path distances from 'A' to all nodes in a weighted directed graph and print the distance dictionary.", "incomplete_code": "import heapq\n\ngraph = {\n    'A': {'B': 4, 'C': 1},\n    'B': {'E': 4},\n    'C': {'B': 2, 'D': 4},\n    'D': {'E': 1},\n    'E': {}\n}\n\n\"\"\"We want a dict of minimum distances from 'A' to each node.\n\"\"\"\n\ndef dijkstra(graph, start):\n    dist = {node: float('inf') for node in graph}\n    dist[start] = 0\n    pq = [(0, start)]\n\n    while pq:\n        d, node = heapq.heappop(pq)\n        if d < dist[node]:\n            # BUG: should skip when d > dist[node], not when d < dist[node]\n            continue\n        for neigh, w in graph[node].items():\n            nd = d + w\n            if nd < dist[neigh]:\n                dist[neigh] = nd\n                heapq.heappush(pq, (nd, neigh))\n\n    return dist\n\nprint(dijkstra(graph, 'A'))\n"}, "output": {"code_output": null, "tries": 0}, "target": "{'A': 0, 'B': 3, 'C': 1, 'D': 5, 'E': 6}"}]}