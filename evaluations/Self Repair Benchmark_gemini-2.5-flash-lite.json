{"benchmark_name": "Self Repair Benchmark", "run_id": "gemini-2.5-flash-lite", "results": {"sr": 0.7, "ftsr": 1.0, "scr": 0, "ats": 0.9}, "samples": [{"input": {"input_key": 1, "desired_task": "Count word frequencies (case-insensitive, ignoring punctuation) in a given text and print the top 5 words as (word, count) sorted by descending frequency then alphabetically.", "incomplete_code": "import re\nfrom collections import Counter\n\ntext = \"This is a test. This test is only a test: in case of an actual emergency, the word 'test' would appear many times.\"\n\n# We want something like: [(\"test\", 3), (\"a\", 2), ...]\n\ndef top_k_words(text, k=5):\n    # split on non-letters, normalize case\n    words = re.findall(r\"[a-zA-Z']+\", text)  # BUG: missing .lower()\n    counts = Counter(words)\n\n    # sort by frequency desc, then word asc\n    # BUG: this is sorting by word first, then frequency\n    items = sorted(counts.items(), key=lambda kv: (kv[0], -kv[1]))\n    return items[:k]\n\nprint(top_k_words(text, k=5))\n"}, "output": {"code_output": null, "tries": 0}, "target": "[('test', 3), ('a', 2), ('is', 2), ('this', 2), (\"'test'\", 1)]"}, {"input": {"input_key": 7, "desired_task": "Perform a topological sort of a small DAG of tasks and print one valid ordering.", "incomplete_code": "from collections import deque\n\ngraph = {\n    'cook': ['eat'],\n    'shop': ['cook'],\n    'code': ['sleep'],\n    'eat': ['sleep'],\n    'sleep': []\n}\n\n\"\"\"We want a valid topological ordering such as:\n['code', 'shop', 'cook', 'eat', 'sleep']\n\"\"\"\n\ndef topo_sort(graph):\n    indeg = {node: 0 for node in graph}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            indeg[v] += 1\n\n    # queue of nodes with indegree 0\n    queue = deque([n for n, d in indeg.items() if d == 0])\n    order = []\n\n    while queue:\n        # BUG: using pop() instead of popleft() breaks deterministic BFS order\n        node = queue.pop()\n        order.append(node)\n        for v in graph[node]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                queue.append(v)\n\n    if len(order) != len(graph):\n        raise ValueError('graph has a cycle')\n\n    return order\n\nprint(topo_sort(graph))\n"}, "output": {"code_output": "['shop', 'code', 'cook', 'eat', 'sleep']", "tries": 2}, "target": "['code', 'shop', 'cook', 'eat', 'sleep']"}, {"input": {"input_key": 9, "desired_task": "Compute the length of the Longest Increasing Subsequence (LIS) in a list of integers using an efficient O(n log n) approach and print that length.", "incomplete_code": "import bisect\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n\"\"\"We want the length of the LIS (not necessarily contiguous).\nFor the above, the LIS length is 4.\n\"\"\"\n\ndef lis_length(nums):\n    tails = []  # tails[i] = smallest tail of an increasing subseq of length i+1\n    for x in nums:\n        # BUG: using bisect_right creates non-strictly-increasing subsequences\n        i = bisect.bisect_right(tails, x)\n        if i == len(tails):\n            tails.append(x)\n        else:\n            tails[i] = x\n    return len(tails)\n\nprint(lis_length(nums))\n"}, "output": {"code_output": null, "tries": 0}, "target": "4"}, {"input": {"input_key": 13, "desired_task": "Parse simple log lines of the form 'user=<name> action=<action>' and group actions per user in an OrderedDict, then print that mapping.", "incomplete_code": "import re\nimport collections\n\nlogs = [\n    \"user=alice action=login\",\n    \"user=bob action=download\",\n    \"user=alice action=upload\",\n    \"user=alice action=logout\",\n    \"user=bob action=logout\",\n]\n\n\"\"\"We want an OrderedDict mapping user -> list of actions in order of appearance.\n\"\"\"\n\ndef group_actions(logs):\n    pattern = re.compile(r\"user=(\\\\w+) action=(\\\\w+)\")\n    result = collections.OrderedDict()\n    for line in logs:\n        m = pattern.search(line)\n        if not m:\n            continue\n        user, action = m.groups()\n        if user not in result:\n            # BUG: accidentally overwrite existing mapping instead of appending list\n            result[user] = action\n        else:\n            # BUG: trying to append to string\n            result[user] += \",\" + action\n    return result\n\nprint(group_actions(logs))\n"}, "output": {"code_output": "OrderedDict()", "tries": 2}, "target": "OrderedDict([('alice', ['login', 'upload', 'logout']), ('bob', ['download', 'logout'])])"}, {"input": {"input_key": 17, "desired_task": "Generate all permutations of a small list of integers, sort them lexicographically, and print the list of permutations.", "incomplete_code": "import itertools\n\nnums = [1, 2, 3]\n\n\"\"\"We want all permutations in sorted order, e.g.:\n[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]\n\"\"\"\n\ndef all_permutations(nums):\n    perms = list(itertools.permutations(nums))\n    # BUG: not sorted; current order depends on itertools implementation\n    return perms\n\nprint(all_permutations(nums))\n"}, "output": {"code_output": null, "tries": 0}, "target": "[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]"}, {"input": {"input_key": 19, "desired_task": "Use Dijkstra's algorithm to compute the shortest path distances from 'A' to all nodes in a weighted directed graph and print the distance dictionary.", "incomplete_code": "import heapq\n\ngraph = {\n    'A': {'B': 4, 'C': 1},\n    'B': {'E': 4},\n    'C': {'B': 2, 'D': 4},\n    'D': {'E': 1},\n    'E': {}\n}\n\n\"\"\"We want a dict of minimum distances from 'A' to each node.\n\"\"\"\n\ndef dijkstra(graph, start):\n    dist = {node: float('inf') for node in graph}\n    dist[start] = 0\n    pq = [(0, start)]\n\n    while pq:\n        d, node = heapq.heappop(pq)\n        if d < dist[node]:\n            # BUG: should skip when d > dist[node], not when d < dist[node]\n            continue\n        for neigh, w in graph[node].items():\n            nd = d + w\n            if nd < dist[neigh]:\n                dist[neigh] = nd\n                heapq.heappush(pq, (nd, neigh))\n\n    return dist\n\nprint(dijkstra(graph, 'A'))\n"}, "output": {"code_output": null, "tries": 0}, "target": "{'A': 0, 'B': 3, 'C': 1, 'D': 5, 'E': 6}"}]}