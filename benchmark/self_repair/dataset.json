[
  {
    "desired_task": "Group a sorted list of integers into maximal consecutive ranges and print the list of (start, end) tuples.",
    "incomplete_code": "nums = [1, 2, 3, 5, 6, 10, 11, 12, 15]\n\ndef group_consecutive(nums):\n    \"\"\"\n    Given a list of integers, return a list of (start, end) tuples\n    representing maximal consecutive ranges.\n    Example: [1,2,3,5] -> [(1,3), (5,5)]\n    \"\"\"\n    if not nums:\n        return []\n\n    ranges = []\n    start = nums[0]\n    prev = nums[0]\n\n    for x in nums[1:]:\n        if x == prev + 1:\n            # still in the same range\n            prev = x\n        else:\n            ranges.append((start, prev))\n            start = x\n            prev = x\n\n    # TODO: this function forgets to close the last range\n    # ranges.append((start, prev))\n\n    return ranges\n\nprint(group_consecutive(nums))\n",
    "correct_output": "[(1, 3), (5, 6), (10, 12), (15, 15)]"
  },
  {
    "desired_task": "Count word frequencies (case-insensitive, ignoring punctuation) in a given text and print the top 5 words as (word, count) sorted by descending frequency then alphabetically.",
    "incomplete_code": "import re\nfrom collections import Counter\n\ntext = \"This is a test. This test is only a test: in case of an actual emergency, the word 'test' would appear many times.\"\n\n# We want something like: [(\"test\", 3), (\"a\", 2), ...]\n\ndef top_k_words(text, k=5):\n    # split on non-letters, normalize case\n    words = re.findall(r\"[a-zA-Z']+\", text)  # BUG: missing .lower()\n    counts = Counter(words)\n\n    # sort by frequency desc, then word asc\n    # BUG: this is sorting by word first, then frequency\n    items = sorted(counts.items(), key=lambda kv: (kv[0], -kv[1]))\n    return items[:k]\n\nprint(top_k_words(text, k=5))\n",
    "correct_output": "[('test', 3), ('a', 2), ('is', 2), ('this', 2), (\"'test'\", 1)]"
  },
  {
    "desired_task": "Rotate a 3x3 matrix 90 degrees clockwise and print the resulting matrix as a list of lists.",
    "incomplete_code": "matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n]\n\n\"\"\"Desired:\n[[7,4,1],\n [8,5,2],\n [9,6,3]]\n\"\"\"\n\ndef rotate_clockwise(mat):\n    n = len(mat)\n    # BUGGY attempt: transpose but not reverse rows/columns correctly\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            # this maps to 90 deg counter-clockwise\n            result[i][j] = mat[j][i]\n    return result\n\nprint(rotate_clockwise(matrix))\n",
    "correct_output": "[[7, 4, 1], [8, 5, 2], [9, 6, 3]]"
  },
  {
    "desired_task": "Merge overlapping intervals and print the merged list of [start, end] intervals.",
    "incomplete_code": "intervals = [[1, 3], [2, 6], [8, 10], [15, 18], [17, 20]]\n\n\"\"\"Expected merged:\n[[1, 6], [8, 10], [15, 20]]\n\"\"\"\n\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n\n    # BUG: not sorting by start\n    intervals = list(intervals)\n\n    merged = []\n    current_start, current_end = intervals[0]\n\n    for start, end in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append([current_start, current_end])\n            current_start, current_end = start, end\n\n    merged.append([current_start, current_end])\n    return merged\n\nprint(merge_intervals(intervals))\n",
    "correct_output": "[[1, 6], [8, 10], [15, 20]]"
  },
  {
    "desired_task": "Compute the length of the shortest path in an unweighted directed graph from 'A' to 'F' using BFS and print that distance.",
    "incomplete_code": "from collections import deque\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': ['D', 'E'],\n    'D': ['F'],\n    'E': ['F'],\n    'F': []\n}\n\n# We want the minimum number of edges from 'A' to 'F'.\n\ndef shortest_path_length(graph, start, target):\n    queue = deque([(start, 0)])\n    seen = set()\n\n    while queue:\n        node, dist = queue.popleft()\n        if node in seen:\n            continue\n        seen.add(node)\n\n        if node == target:\n            return dist\n\n        for neigh in graph.get(node, []):\n            # BUG: forgot to increment distance\n            queue.append((neigh, dist))\n\n    return None\n\nprint(shortest_path_length(graph, 'A', 'F'))\n",
    "correct_output": "3"
  },
  {
    "desired_task": "Count the number of connected components (4-directionally) of 1s in a 2D grid and print the count.",
    "incomplete_code": "grid = [\n    [1, 1, 0, 0],\n    [0, 1, 0, 1],\n    [1, 0, 0, 1],\n    [0, 0, 1, 1],\n]\n\n\"\"\"We want to count islands of 1s using 4-directional adjacency.\n\"\"\"\n\ndef count_islands(grid):\n    rows = len(grid)\n    cols = len(grid[0]) if rows else 0\n    visited = [[False] * cols for _ in range(rows)]\n\n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if visited[r][c] or grid[r][c] == 0:\n            return\n        visited[r][c] = True\n        # BUG: includes diagonal neighbors instead of 4-directional\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                dfs(r + dr, c + dc)\n\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                count += 1\n                dfs(i, j)\n\n    return count\n\nprint(count_islands(grid))\n",
    "correct_output": "3"
  },
  {
    "desired_task": "Simulate an LRU cache (most-recently-used at front) of capacity 3 for a sequence of accesses and print the final cache content from most to least recent.",
    "incomplete_code": "def simulate_lru(capacity, accesses):\n    cache = []  # most recent at front index 0\n    for x in accesses:\n        if x in cache:\n            # move to front\n            cache.remove(x)\n            cache.insert(0, x)\n        else:\n            cache.append(x)  # BUG: should insert at front\n            if len(cache) > capacity:\n                cache.pop(0)  # BUG: evicting from wrong end\n    return cache\n\nprint(simulate_lru(3, [1, 2, 3, 2, 4, 1, 5, 2]))\n",
    "correct_output": "[2, 5, 1]"
  },
  {
    "desired_task": "Perform a topological sort of a small DAG of tasks and print one valid ordering.",
    "incomplete_code": "from collections import deque\n\ngraph = {\n    'cook': ['eat'],\n    'shop': ['cook'],\n    'code': ['sleep'],\n    'eat': ['sleep'],\n    'sleep': []\n}\n\n\"\"\"We want a valid topological ordering such as:\n['code', 'shop', 'cook', 'eat', 'sleep']\n\"\"\"\n\ndef topo_sort(graph):\n    indeg = {node: 0 for node in graph}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            indeg[v] += 1\n\n    # queue of nodes with indegree 0\n    queue = deque([n for n, d in indeg.items() if d == 0])\n    order = []\n\n    while queue:\n        # BUG: using pop() instead of popleft() breaks deterministic BFS order\n        node = queue.pop()\n        order.append(node)\n        for v in graph[node]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                queue.append(v)\n\n    if len(order) != len(graph):\n        raise ValueError('graph has a cycle')\n\n    return order\n\nprint(topo_sort(graph))\n",
    "correct_output": "['code', 'shop', 'cook', 'eat', 'sleep']"
  },
  {
    "desired_task": "Compute the maximum nesting depth of a nested list structure and print that depth (non-list elements contribute only through their containing lists).",
    "incomplete_code": "nested = [1, [2, [3, 4], 5], [], [6, [7, [8]]]]\n\n\"\"\"Depth is defined as:\n- a non-list has depth 0\n- an empty list has depth 1\n- a non-empty list has depth 1 + max(depth of its elements)\n\"\"\"\n\ndef max_depth(obj):\n    if not isinstance(obj, list):\n        return 1  # BUG: non-list should be depth 0\n    if not obj:\n        return 0  # BUG: empty list should be depth 1\n    return 1 + max(max_depth(x) for x in obj)\n\nprint(max_depth(nested))\n",
    "correct_output": "4"
  },
  {
    "desired_task": "Compute the length of the Longest Increasing Subsequence (LIS) in a list of integers using an efficient O(n log n) approach and print that length.",
    "incomplete_code": "import bisect\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n\"\"\"We want the length of the LIS (not necessarily contiguous).\nFor the above, the LIS length is 4.\n\"\"\"\n\ndef lis_length(nums):\n    tails = []  # tails[i] = smallest tail of an increasing subseq of length i+1\n    for x in nums:\n        # BUG: using bisect_right creates non-strictly-increasing subsequences\n        i = bisect.bisect_right(tails, x)\n        if i == len(tails):\n            tails.append(x)\n        else:\n            tails[i] = x\n    return len(tails)\n\nprint(lis_length(nums))\n",
    "correct_output": "4"
  },
  {
    "desired_task": "Find the length of the longest substring of a string without repeating characters and print that length.",
    "incomplete_code": "s = \"abrkaabcdefghijjxxx\"\n\n\"\"\"We want the maximum length of any substring with all distinct characters.\n\"\"\"\n\ndef longest_unique_substring(s):\n    last = {}\n    start = 0\n    best = 0\n    for i, ch in enumerate(s):\n        if ch in last and last[ch] >= start:\n            # BUG: should move start to last[ch] + 1, but off by one here\n            start = last[ch]\n        last[ch] = i\n        best = max(best, i - start + 1)\n    return best\n\nprint(longest_unique_substring(s))\n",
    "correct_output": "10"
  },
  {
    "desired_task": "Sort a list of records by id ascending and serialize them to a compact JSON string with keys sorted, then print that string.",
    "incomplete_code": "import json\n\nrecords = [\n    {\"id\": 3, \"name\": \"C\"},\n    {\"id\": 1, \"name\": \"A\"},\n    {\"id\": 2, \"name\": \"B\"},\n]\n\n\"\"\"We want a JSON string like:\n[{\"id\":1,\"name\":\"A\"},{\"id\":2,\"name\":\"B\"},{\"id\":3,\"name\":\"C\"}]\n\"\"\"\n\ndef serialize_records(records):\n    # BUG: sorts by name instead of id\n    sorted_records = sorted(records, key=lambda r: r[\"name\"])\n    # BUG: pretty printing instead of compact + sorted keys\n    return json.dumps(sorted_records)\n\nprint(serialize_records(records))\n",
    "correct_output": "[{\"id\":1,\"name\":\"A\"},{\"id\":2,\"name\":\"B\"},{\"id\":3,\"name\":\"C\"}]"
  },
  {
    "desired_task": "Compute the number of distinct ways to make up a target amount using given coin denominations (unlimited coins), order-insensitive, and print that count.",
    "incomplete_code": "coins = [1, 2, 5]\namount = 11\n\n\"\"\"We want the classical coin-change (combinations) count.\nOrder of coins does not matter.\n\"\"\"\n\ndef count_ways(coins, amount):\n    # dp[x] = number of ways to make sum x\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n\n    # BUG: iterating amount outer, coins inner counts permutations not combinations\n    for x in range(1, amount + 1):\n        for c in coins:\n            if x - c >= 0:\n                dp[x] += dp[x - c]\n    return dp[amount]\n\nprint(count_ways(coins, amount))\n",
    "correct_output": "11"
  },
  {
    "desired_task": "Parse simple log lines of the form 'user=<name> action=<action>' and group actions per user in an OrderedDict, then print that mapping.",
    "incomplete_code": "import re\nimport collections\n\nlogs = [\n    \"user=alice action=login\",\n    \"user=bob action=download\",\n    \"user=alice action=upload\",\n    \"user=alice action=logout\",\n    \"user=bob action=logout\",\n]\n\n\"\"\"We want an OrderedDict mapping user -> list of actions in order of appearance.\n\"\"\"\n\ndef group_actions(logs):\n    pattern = re.compile(r\"user=(\\\\w+) action=(\\\\w+)\")\n    result = collections.OrderedDict()\n    for line in logs:\n        m = pattern.search(line)\n        if not m:\n            continue\n        user, action = m.groups()\n        if user not in result:\n            # BUG: accidentally overwrite existing mapping instead of appending list\n            result[user] = action\n        else:\n            # BUG: trying to append to string\n            result[user] += \",\" + action\n    return result\n\nprint(group_actions(logs))\n",
    "correct_output": "OrderedDict([('alice', ['login', 'upload', 'logout']), ('bob', ['download', 'logout'])])"
  },
  {
    "desired_task": "Evaluate an arithmetic expression string with +, -, *, / and integer division semantics, honoring operator precedence, and print the resulting integer.",
    "incomplete_code": "def eval_expr(expr):\n    \"\"\"Evaluate a flat expression like '3+5*2-8/4+6' using integer division.\n    No parentheses.\n    \"\"\"\n    # BUG: naive left-to-right evaluation ignoring precedence\n    total = 0\n    op = '+'\n    num = 0\n    for ch in expr + '+':\n        if ch.isdigit():\n            num = num * 10 + int(ch)\n        else:\n            if op == '+':\n                total += num\n            elif op == '-':\n                total -= num\n            elif op == '*':\n                total *= num\n            elif op == '/':\n                total //= num\n            op = ch\n            num = 0\n    return total\n\nexpr = '3+5*2-8/4+6'\nprint(eval_expr(expr))\n",
    "correct_output": "17"
  },
  {
    "desired_task": "Count all palindromic substrings in a string (including single characters) and print that count.",
    "incomplete_code": "s = 'ababa'\n\n\"\"\"We should count all palindromic substrings, e.g. for 'ababa' the answer is 9.\n\"\"\"\n\ndef count_palindromes(s):\n    n = len(s)\n    count = 0\n    # BUG: only odd-length palindromes, missing even-length centers\n    for center in range(n):\n        l = r = center\n        while l >= 0 and r < n and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n    return count\n\nprint(count_palindromes(s))\n",
    "correct_output": "9"
  },
  {
    "desired_task": "Sort a list of (name, score) tuples by score descending, then by name ascending, and print the sorted list.",
    "incomplete_code": "people = [\n    ('alice', 3),\n    ('bob', 2),\n    ('carol', 3),\n    ('dave', 1),\n]\n\n\"\"\"We want something like:\n[('alice', 3), ('carol', 3), ('bob', 2), ('dave', 1)]\n\"\"\"\n\ndef custom_sort(records):\n    # BUG: sorts ascending by score and descending by name\n    return sorted(records, key=lambda x: (x[1], -ord(x[0][0])))\n\nprint(custom_sort(people))\n",
    "correct_output": "[('alice', 3), ('carol', 3), ('bob', 2), ('dave', 1)]"
  },
  {
    "desired_task": "Generate all permutations of a small list of integers, sort them lexicographically, and print the list of permutations.",
    "incomplete_code": "import itertools\n\nnums = [1, 2, 3]\n\n\"\"\"We want all permutations in sorted order, e.g.:\n[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]\n\"\"\"\n\ndef all_permutations(nums):\n    perms = list(itertools.permutations(nums))\n    # BUG: not sorted; current order depends on itertools implementation\n    return perms\n\nprint(all_permutations(nums))\n",
    "correct_output": "[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]"
  },
  {
    "desired_task": "Perform one step of Conway's Game of Life on a 3x3 board and print the resulting board as a list of lists.",
    "incomplete_code": "board = [\n    [0, 1, 0],\n    [0, 1, 0],\n    [0, 1, 0],\n]\n\n\"\"\"We want to apply one iteration of Conway's Game of Life rules.\n\"\"\"\n\ndef step(board):\n    rows = len(board)\n    cols = len(board[0]) if rows else 0\n    new = [[0] * cols for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = 0\n            for dr in (-1, 0, 1):\n                for dc in (-1, 0, 1):\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        live_neighbors += board[nr][nc]\n\n            if board[r][c] == 1:\n                # BUG: wrong survival condition\n                new[r][c] = 1 if live_neighbors >= 2 else 0\n            else:\n                new[r][c] = 1 if live_neighbors == 2 else 0  # BUG: should be 3\n\n    return new\n\nprint(step(board))\n",
    "correct_output": "[[0, 0, 0], [1, 1, 1], [0, 0, 0]]"
  },
  {
    "desired_task": "Use Dijkstra's algorithm to compute the shortest path distances from 'A' to all nodes in a weighted directed graph and print the distance dictionary.",
    "incomplete_code": "import heapq\n\ngraph = {\n    'A': {'B': 4, 'C': 1},\n    'B': {'E': 4},\n    'C': {'B': 2, 'D': 4},\n    'D': {'E': 1},\n    'E': {}\n}\n\n\"\"\"We want a dict of minimum distances from 'A' to each node.\n\"\"\"\n\ndef dijkstra(graph, start):\n    dist = {node: float('inf') for node in graph}\n    dist[start] = 0\n    pq = [(0, start)]\n\n    while pq:\n        d, node = heapq.heappop(pq)\n        if d < dist[node]:\n            # BUG: should skip when d > dist[node], not when d < dist[node]\n            continue\n        for neigh, w in graph[node].items():\n            nd = d + w\n            if nd < dist[neigh]:\n                dist[neigh] = nd\n                heapq.heappush(pq, (nd, neigh))\n\n    return dist\n\nprint(dijkstra(graph, 'A'))\n",
    "correct_output": "{'A': 0, 'B': 3, 'C': 1, 'D': 5, 'E': 6}"
  }
]
